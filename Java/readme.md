## java 基础知识

### Java基础知识
#### volatile
* **内存模型**

```properties
JMM 模型，工作内存，主内存
```


* **volatile 的主要作用** <br/>
	<font color=red>当变量申明为volatile 之后， 寄存器在运行时都会注意到这个变量是共享的，因此不会将该变量的操作与其他内存操作进行重排序。
	volatile 的变量不会被缓存在寄存器或者其他处理器不可以见的地方，因此每次读取的volatile 变量值总是最新的。
	首先禁止重排序，保证了每次对于这个共享变量的操作是串行的，然后当需要这个值的时候，其实每次读取的就是最新的值</font>
	Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，
	编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，
	因此在读取volatile类型的变量时总会返回最新写入的值。
	在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。

```properties
1. 可见性
2. 有序性 <禁止指令重排> 
	synchronized 同样可以保证有序性，不过synchronized 是通过限制在同一个时刻只允许一个线程对其lock 来保证有序性
```

* **volatile 如何实现将工作内存的数据刷新到主内存**<br/>
   缓存一致协议，cpu 在写数据的时候，如果发现这个变量是共享变量，那么会通知所有使用到这个变量的其他cpu，将这个变量的缓存失效，当其他CPU 需要使用这个变量的时候
   重新从主存里面去获取
   
```java
	1. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；
	即在执行到内存屏障这句指令时，在它前面的操作已经全部完成
　　	2. 它会强制将对缓存的修改操作立即写入主存
　　	3. 如果是写操作，它会导致其他CPU中对应的缓存行无效.
```


** 在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障； **

#### final
1. **如何解决可见性**
由于final修饰的变量是常量，也就是说不可变的，因为final在类加载或者类初始化的时候已经确定了final修饰的变量的值，所以final可以保证可见性。
2. **如果解决有序性**
final的有序性也是通过重排序规则来保证的，对于final域，编译器和处理器要遵守以下两个重排序规则。
1)、在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。
```java
即先赋值final 域，再将包含final 域的对象赋予其他对象进行应用
```
2)、初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。
```java
即先读取包含final 域的对象，再读取final 值
```

*写final域重排序规则* <br/>
写final域的重排序规则禁止把final域的写重排序到构造函数之外。这个规则包含两方面
	> JMM禁止编译器把final域的写重排序到构造函数之外。
	> 编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外
写final域的重排序规则可以确保：在**对象引用**为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域就不具有这个保障。

读final域重排序规则
读final域的重排序规则是，在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作(注意，这个规则仅仅针对处理器)。编译器会在读final域操作的前面插入一个LoadLoad屏障。
final引用不能从构造函数内“溢出”
读final域的重排序规则可以确保：在读一个对象的final域之前，**一定会先读这个包含这个final域的对象的引用。**

#### static
#### java 中volatile ， final ， synchronized 都是怎样保证可见性，有序性和原子性
1.Synchronized 主要是通过加锁的方式保证有序性
当释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。
当获取锁时，JMM会把该线程对应的本地内存置为无效，从而使得被监视其保护的临界区代码必须从主内存中读取共享变量。

#### Happens-Before规则

### 集合类的关系与梳理
#### 集合类的继承关系
#### hashmap 与 hashtable 的关系
#### 源码知识hashmap/ConcurrentHashMap
#### JUC 知识
> ConcurrentHashMap

```java
```
> CopyOnWriteArrayList

```java
```

### 线程相关知识
#### 线程状态 与转变
#### 线程间通信
#### 锁synchorized/Lock/CountDownLatch/CycleBarire
### 线程池
#### 基本参数 及原理
#### AQS
### JVM
#### 对象引用的方式
#### 对象计数方式
#### 垃圾回收算法
#### 垃圾回收器